From 36a7c02c7c7e8e9c7611d23052c740306201d3e5 Mon Sep 17 00:00:00 2001
From: Tanel Dettenborn <tanel@ssrc.tii.ae>
Date: Wed, 21 May 2025 16:04:27 +0300
Subject: [PATCH] POC: Identity key (pkcs11 fetches key from pta)

Signed-off-by: Tanel Dettenborn <tanel@ssrc.tii.ae>
---
 optee/optee_os/ta/pkcs11/src/attributes.c     | 11 +++
 .../optee_os/ta/pkcs11/src/sanitize_object.c  | 71 ++++++++++++++++++-
 2 files changed, 81 insertions(+), 1 deletion(-)

diff --git a/optee/optee_os/ta/pkcs11/src/attributes.c b/optee/optee_os/ta/pkcs11/src/attributes.c
index 8f6071c15..fa31bc7b6 100644
--- a/optee/optee_os/ta/pkcs11/src/attributes.c
+++ b/optee/optee_os/ta/pkcs11/src/attributes.c
@@ -18,6 +18,15 @@
 #include "pkcs11_helpers.h"
 #include "serializer.h"
 
+static void pri_buf(const char *title, uint32_t id, uint8_t *ptr, size_t len)
+{
+       int k = 0;
+
+       for (k = 0; k < len; ++k) {
+		   EMSG("[%s][%x]: unit[%u] hex[%x]\n", title, id, ptr[k], ptr[k]);
+       }
+}
+
 enum pkcs11_rc init_attributes_head(struct obj_attrs **head)
 {
 	*head = TEE_Malloc(sizeof(**head), TEE_MALLOC_FILL_ZERO);
@@ -35,6 +44,8 @@ enum pkcs11_rc add_attribute(struct obj_attrs **head, uint32_t attribute,
 	enum pkcs11_rc rc = PKCS11_CKR_OK;
 	uint32_t data32 = 0;
 
+	pri_buf("add_attribute", attribute,data,size);
+
 	data32 = attribute;
 	rc = serialize(bstart, &buf_len, &data32, sizeof(uint32_t));
 	if (rc)
diff --git a/optee/optee_os/ta/pkcs11/src/sanitize_object.c b/optee/optee_os/ta/pkcs11/src/sanitize_object.c
index 132833284..2561abab8 100644
--- a/optee/optee_os/ta/pkcs11/src/sanitize_object.c
+++ b/optee/optee_os/ta/pkcs11/src/sanitize_object.c
@@ -245,6 +245,60 @@ out:
 	return rc;
 }
 
+#define JETSON_USER_KEY_TA_UUID \
+	{ 0xe9e156e8, 0xe161, 0x4c8a, \
+		{0x91, 0xa9, 0x0b, 0xba, 0x5e, 0x24, 0x7e, 0xe8} }
+#define JETSON_USER_KEY_CMD_POC_GEN_AND_GET_IDENTITY_KEY 10
+
+static TEE_Result fetch_identity_key(uint8_t **identity_key, size_t *identity_key_len)
+{
+	TEE_Result rv = TEE_ERROR_GENERIC;
+    TEE_TASessionHandle sess = TEE_HANDLE_NULL;
+    uint32_t rv_org = 0;
+	uint32_t ta2ta_params_type = 0;
+	TEE_Param ta2ta_params[TEE_NUM_PARAMS] = {0};
+	size_t identity_key_buf_len = 64;
+
+	*identity_key = TEE_Malloc(identity_key_buf_len, TEE_MALLOC_FILL_ZERO);
+	if (*identity_key == NULL) {
+		EMSG("fetch_identity_key: TEE_Malloc failed");
+		rv = TEE_ERROR_OUT_OF_MEMORY;
+		goto err_out;
+	}
+
+    rv = TEE_OpenTASession(&(const TEE_UUID)JETSON_USER_KEY_TA_UUID,
+                            TEE_TIMEOUT_INFINITE, 0, NULL, &sess,
+                            &rv_org);
+    if (rv) {
+        EMSG("fetch_identity_key: TEE_OpenTASession failed rv[0x%08x]; rv_org[%u]\n", rv, rv_org);
+		goto err_out;
+    }
+
+	ta2ta_params_type = TEE_PARAM_TYPES(TEE_PARAM_TYPE_MEMREF_OUTPUT,
+										TEE_PARAM_TYPE_NONE,
+										TEE_PARAM_TYPE_NONE,
+										TEE_PARAM_TYPE_NONE);
+	ta2ta_params[0].memref.buffer = *identity_key;
+	ta2ta_params[0].memref.size = identity_key_buf_len;
+	rv = TEE_InvokeTACommand(sess, TEE_TIMEOUT_INFINITE,
+							 JETSON_USER_KEY_CMD_POC_GEN_AND_GET_IDENTITY_KEY,
+							 ta2ta_params_type, ta2ta_params, &rv_org);
+	if (rv) {
+        EMSG("fetch_identity_key: TEE_InvokeTACommand failed rv[0x%08x]; rv_org[%u]\n", rv, rv_org);
+		goto err_out;
+	}
+
+	*identity_key_len = ta2ta_params[0].memref.size;
+	goto out;
+
+err_out:
+	TEE_Free(*identity_key);
+
+out:
+    TEE_CloseTASession(sess);
+    return rv;
+}
+
 enum pkcs11_rc sanitize_client_object(struct obj_attrs **dst, void *src,
 				      size_t size, uint32_t class_hint,
 				      uint32_t type_hint)
@@ -255,6 +309,9 @@ enum pkcs11_rc sanitize_client_object(struct obj_attrs **dst, void *src,
 	size_t pos = sizeof(head);
 	size_t sz_from_hdr = 0;
 	void *data = NULL;
+	uint8_t *identity_key = NULL;
+	size_t identity_key_len = 0;
+	uint8_t ec_identity_fetch_trigger[] = "\xf5\x13\x56\x10\x42\x2a\xde\x02\xdd\xd7\xb9\xd3\xf7\x50\xcd\x83\x78\x33\xab\xa5\xed\x40\x17\x58\x81\x29\x60\x12\x39\x80\xd5\xf5\xdb\xc7\xbc\x26\xb0\xb2\x47\x4c\xf9\xe9\x9e\xdd\x37\x46\xe5\x26";
 
 	if (size < sizeof(head))
 		return PKCS11_CKR_ARGUMENTS_BAD;
@@ -301,7 +358,19 @@ enum pkcs11_rc sanitize_client_object(struct obj_attrs **dst, void *src,
 			return PKCS11_CKR_TEMPLATE_INCONSISTENT;
 		}
 
-		rc = add_attribute(dst, cli_ref.id, data, cli_ref.size);
+		if (cli_ref.id == PKCS11_CKA_VALUE &&
+			cli_ref.size == (sizeof(ec_identity_fetch_trigger) -1) &&
+			TEE_MemCompare(data, ec_identity_fetch_trigger, cli_ref.size) == 0) {
+			if (fetch_identity_key(&identity_key, &identity_key_len) == TEE_SUCCESS) {
+				rc = add_attribute(dst, cli_ref.id, identity_key, identity_key_len);
+				TEE_Free(identity_key);
+			} else {
+				EMSG("sanitize_client_object: Failed to fetch identity key");
+				rc = PKCS11_CKR_GENERAL_ERROR;
+			}
+		} else {
+			rc = add_attribute(dst, cli_ref.id, data, cli_ref.size);
+		}
 		if (rc)
 			return rc;
 	}
-- 
2.47.2

